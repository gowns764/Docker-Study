# 도커 스웜

## 1. 도커 스웜을 사용하는 이유
- 하나의 호스트 머신에서 도커 엔진을 구동하다가 자원이 부족하면, 일반적으로 여러 대의 서버를 클러스터로 만들어 자원을 확장한다.
- 그러나 이는 쉬운 작업이 아니며 스케줄러, 로드밸런서, 고가용성 보장 등의 문제가 있는데 이를 해결하는 방법이 **도커 스웜**과 **스웜 모드**이다.

## 2. 스웜 클래식과 도커 스웜 모드
- 스웜 클래식과 스웜 모드는 여러 대의 도커 서버를 하나의 클러스터로 만들어 컨테이너를 생성하는 여러 기능을 제공한다.
- 도커 스웜에는 두 가지 종류가 있다.
    1. **스웜 클래식**
       - 여러 대의 도커 서버를 하나의 지점에서 사용하도록 단일 접근점을 제공한다.
       - 일반적인 도커 명령어와 도커 API로 클러스터의 서버를 제어하고 관리하는 기능을 제공한다.
       - 분산 코디네이터, 에이전트 등이 별도로 실행되어야 한다.
    2. **스웜 모드** (권장!)
       - 마이크로사비스 아키텍쳐의 컨테이너를 다루기 위한 클러스터링 기능에 초점을 맞춘다.
       - 같은 컨테이너를 동시에 여러 개 생성해 필요에 따라 유동적으로 컨테이너의 수를 조절할 수 있으며, 컨테이너로의 연결을 분산하는 로드밸런싱 기능을 자체적으로 지원한다.
       - 클러스터링을 위한 모든 도구가 도커 엔진 자체에 내장되어 있기 때문에 상대적으로 쉽게 서버 클러스터를 구축할 수 있다.

## 3. 스웜 모드
- `docker info` 명령어를 통해 도커 엔진의 스웜 모드 클러스터 정보를 확인할 수 있다.
  - 단일 도커 서버에서 사용중일 때는 스웜 모드의 상태가 비활성(inactive)으로 설정되어 있다.

### 3.1. 도커 스웜 모드의 구조
- 스웜 모드는 **매니저 노드**와 **워커 노드**로 구성되어 있다.
  - 워커 노드는 실제로 컨테이너가 생성되고 관리되는 도커 서버이다.
  - 매니저 노드는 워커 노드를 관리하기 위한 도커 서버이다.
    - 매니저 노드에도 컨테이너가 생성될 수 있다.
    - 즉, 매니저 노드는 기본적으로 워커 노드의 역할을 포함하고 있다.
- 매니저 노드는 1개 이상이 있어야 하지만, 워커 노드는 없을 수도 있다.
  - 매니저 노드가 워커 노드의 역할도 포함하고 있어, 매니저 모드만으로도 스웜 클러스터를 구성할 수 있기 때문이다.
  - 그러나, 일반적으로 워커 노드와 매니저 노드를 구분해서 사용하는 것을 권장한다.
- 실제 운영 환경에서 스웜 모드로 도커 클러스터를 구설하려면 매니저 노드를 다중화하는 것을 권장한다.
  - 매니저의 부하를 분산하고 특정 매니저 노드가 다운됐을 때 정상적으로 스웜 클러스터를 유지할 수 있기 때문이다.
- 스웜 모드는 매니저 노드의 절반 이상에 장애가 생길 경우, 장애가 생긴 매니저 노드가 복구될 때까지 클러스터의 운영을 중단한다.
  - 매니저 노드 사이에 네트워크 파티셔닝과 같은 현상이 발생했을 경우, 짝수 개의 매니저로 구성한 클러스터는 운영이 중단될 수도 있지만, 홀수 개로 구성했을 경우에는 과반수 이상이 유지되는 쿼럼 매니저에서 운영을 계속할 수 있다.
    - 따라서, 스웜 매니저는 가능한 한 홀수 개로 구성하는 것이 권장된다.

### 3.2. 도커 스웜 모드 클러스터 구축
1. `docker swarm init` 명령어를 입력해 매니저 역할을 할 서버에서 스웜 클러스터를 시작한다.
   - 예) `docker swarm init --advertise-addr 192.168.0.100`
   - `--advertise-addr`에는 다른 도커 서버가 매니저 노드에 접근하기 위한 IP 주소를 입력한다.
   - 출력 결과 중 `docker swarm join` 명령어는 새로운 워커 노드를 스웜 클러스터에 추가할 때 사용된다.
   - `--token` 옵션에 사용된 토큰 값은 새로운 노드를 해당 스웜 클러스터에 추가하기 위한 비밀키이다.
2. `docker swarm join --token [매니저 노드의 토큰 값과 IP:포트]` 명령어를 각 워커 노드에서 입력하여 워커 노드를 추가한다.
3. 매니저 노드에서 `docker node ls` 명령어를 입력하여 특정 도커 서버가 정상적으로 스웜 클러스터에 추가됐는지 확인한다.
   - 출력 결과 중 ID 옆에 *가 붙어 있는 노드가 현재서버이다.
- 매니저 노드를 추가하기 위한 토큰은 `docker swarm join-token manager` 명령어로 확인할 수 있다.
- 워커 노드를 추가하기 위한 토큰은 `docker swarm join-token worker` 명령어로 확인할 수 있다.
- 토큰을 갱신하려면 `docker swarm join-token --rotate [변경할 토큰의 대상]` 명령어를 입력한다.
- 추가된 워커 노드를 삭제하고 싶으면 해당 워커 노드에서 `docker swarm leave` 명령어를 입력한다.
  - 이 명령어로 스웜 모드를 해제하면 매니저 노드는 해당 워커 노드의 상태를 Down으로 인지하기 때문에, 매니저 노드에서 `docker node rm [해당 노드의 호스트 이름]` 명령어로 삭제해야 한다.
    - 해당 노드의 호스트 이름은 ID의 앞자리 중 일부만 사용해 제어할 수 있다.
- 매니저 노드는 `docker swarm leave --force` 명령어로 삭제할 수 있다.
  - 매니저 노드를 스웜 클러스터에서 삭제하면, 해당 매니저 노드에 저장되어 있던 클러스터의 정보도 삭제된다.
  - 스웜 클러스터에 매니저 노드가 단 한개만 존재할 때 매니저 노드를 삭제하면 해당 스웜 클러스터는 더 이상 사용하지 못하는 상태가 된다.
- 워커 노드를 매니저 노드로 변경하려면 `docker node promote [워커 노드]` 명령어를 사용한다.
- 매니저 노드를 워커 노드로 변경하려면 `docker node demote [매니저 노드]` 명령어를 사용한다.
  - 단, 매니저 노드가 1개일 때 매니저 노드에 대해 demote 명령어를 사용할 수 없다.
  - 매니저 리더 노드에 demote 명령어를 사용하면 다른 매니저 노드 중 새로운 리더를 선출한다.

### 3.3. 스웜 모드 서비스

#### 3.3.1. 스웜 모드 서비스 개념
- 스웜 모드에서 제어하는 단위는 **서비스**이다.
- 서비스는 같은 이미지에서 생성된 컨테이너의 집합이며, 서비스를 제어하면 해당 서비스 내의 컨테이너에 같은 명령이 수행된다.
- 서비스 내의 컨테이너는 1개 이상 존재할 수 있으,며, 컨테이너들은 각 워커 노드와 매니저 노드에 할당된다.
  - 이러한 서비스 내의 컨테이너를 **태크스**라고 한다.
  - 서비스 내의 컨테이너 == 태스크
- 스웜 스케줄러는 서비스의 정의에 따라 태스크를 할당할 적합한 노드를 선정하고, 해당 노드에 태스크를 분산해서 할당한다.
  - 각 노드에 하나씩 할당되지 않을 수도 있다.
- 이렇게 함께 생성된 태스크를 **레플리카**라고 하며, 서비스에 설정된 레플리카의 수만큼 태스크가 스웜 클러스터 내에 존재해야 한다.
- 스웜은 태스크들에 대한 상태를 계속 확인하고 있다가 서비스 내에 정의된 레플리카의 수만큼 태스크가 스웜 클러스터에 존재하지 않으면, 새로운 태스크 레플리카를 생성한다.
- 컨테이너가 할당된 노드가 다운되면, 매니저는 사용 가능한 다른 노드에 같은 컨테이너를 생성한다.
  - 서버가 다운되지 않더라도 태스크 중 일부가 작동을 멈춰 정지한 상태로 있다면, 이 또한 레플리카의 수를 충족하지 못하는 것으로 판단하여 스웜 매니저는 새로운 태스크를 클러스터에 새롭게 생성한다.
- 서비스는 **롤링 업데이트** 기능도 제공한다.
  - 롤링 업데이트는 여러 개의 서버, 컨테이너 등으로 구성된 클러스터의 설정이나 데이터 등을 변경하기 위해 하나씩 재시작하는 것을 의미한다.
  - 태스크들의 이미지를 일괄적으로 업데이트해야 할 때 태스크들의 이미지를 순서대로 변경해 서비스 자체가 다운되는 시간 없이 태스크의 업데이트를 진핼할 수 있다.

#### 3.3.2. 서비스 생성
- 서비스를 제어하는 도커 명령어는 전부 매니저 노드에서만 사용할 수 있다.

##### 3.3.2.1. 첫 번째 서비스 생성하기
- 서비스를 사용하기 위한 명령어는 `docker service`로 시작한다.
- 서비스를 생성하려면 `docker service reate` 명령어를 사용한다.
  - run 명령어와 비슷한 형식을 띈다.
  - 예) `docker service create ubuntu:14.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"`
    - ubuntu:14.04 이미지로 태스크를 생성하며 태스크가 시작할 때 실행할 명령어로 'hello worl'를 출력하는 셸 명령어를 설정한다.
- 스웜 클러스터 내의 서비스 목록은 `docker service ls` 명령어로 확인한다.
- 서비스의 자세한 정보를 확인하려면 `docker service ps [서비스 이름]` 명령어를 입력한다.
  - 태스크의 목록, 상태, 태스크가 할당된 노드의 위치를 알 수 있다.
- 생성된 서비스를 삭제하려면 `docker service rm [서비스 이름]` 명령어를 입력한다.
  - 서비스의 상태에 관계 없이 태스크를 바로 삭제한다.

##### 3.3.2.2. nginx 웹 서버 서비스 생성하기
- 위에서는 서비스의 레플리카 셋을 정의하지 않았으므로 1개의 태스크만 생성됐다.
- 이번에는 docker service create 명령어에 `--replicas` 옵션을 추가하고, Nginx 웹 서버 이미지를 이용해서 서비스를 외부에 노출한다.
  - 예) `docker service create --name myweb --replicas 2 -p 80:80 nginx`
  - -p 옵션에 80:80을 입력함으로써 스웜 클러스터 자체에 포트를 새방하였다.
  - 따라서, 스웜 클러스터 내의 어떠한 노드로 접근해도 위 서비스의 웨 서버에 접근할 수 있다.
- `docker service scale [서비스 이름]=[수]` 명령어를 이용하여 레플리카 셋의 수를 늘리거나 줄일 수 있다.
  - 예) docker service scale myweb=4
- 하나의 모드에 2개 이상의 태스크가 할당되어도 문제되지 않는다.
  - 각 태스크들이 호스트의 포트에 연결된 것이 아니며, 실제로는 각 노드의 포트로 들어온 요청을 태스크 중 1개로 리다이렉트한다.
  - 따라서, 각 호스트의 어느 노드로 접근하든 4개의 태스크 중 1개에 접근하게 된다.

##### 3.3.2.3. global 서비스 생성하기
- 서비스의 모드는 두 가지가 있다.
  1. **복제 모드**
     - 레플리카 셋의 수를 정의하여 그만큼의 같은 태스크를 생성한다.
     - 실제 서비스를 제공하기 위해 일반적으로 쓰이는 모드이다.
  2. **글로벌 모드**
     - 글로벌 서비스는 스웜 클러스터 내에서 사용할 수 있는 모든 노드에 태스크를 반드시 하나씩 생성한다.
     - 따라서, 글로벌 모드로 생성한 서비스는 레플리카 셋의 수를 별도로 지정하지 않는다.
     - 글로벌 서비스는 스웜 클러스터를 모니터링하기 위한 에이전트 태스크 등을 생성해야 할 때 유용하다.
  - 글로벌 서비스는 docker service create 명령어에 `--mode global`을 추가해 생성할 수 있다.
    - 예) `docker service create --name global_web --mode global nginx`
    - --mode 옵션의 값을 별도로 설정하지 않으면 기본적으로 복제 모드를 사용한다.

#### 3.3.3. 스웜 모드의 서비스 장애 복구
- 복제 모드로 설정된 태스크가 정지하거나 특정 노드가 다운되면 스웜 매니저는 새로운 컨테이너를 생성해 자동으로 이를 복구한다.
- 다운되었던 노드를 다시 시작해 정상적인 상태를 회복해도 장애를 복구하기 위해 다른 노드로 옮겨진 태스크가 해당 노드에 자동으로 할당되지는 않는다.
- 다운되었던 노드를 다시 복구했을 때 서비스의 컨테이너 할당의 균형을 맞추기 위해서는 `scale` 명령어를 이용해 태스크의 수를 줄이고 다시 늘려야 한다.
  - 예)
    - `docker service scale myweb=1`
    - `docker service scale myweb=4`

#### 3.3.4. 서비스 롤링 업데이트
- 스웜 모드는 롤링 업데이트를 자체적으로 지원하며, 간단하게 사용할 수 있다.
1. 롤링 업데이트를 테스트하기 위한 서비스를 생성한다.
   - `docker service create --name myweb2 --replicas 3 nginx:1.10`
2. 서비스가 생성되면 `docker service update --image [업데이트할 이미지] [서비스]` 명령어로 서비스의 이미지를 업데이트할 수 있다.
   - 예) `docker service update --image nginx:1.11 myweb2`
3. docker service ps [서비스] 명령어로 태스크 목록을 확인해보면, NAME 항목에 \\_가 붙어있는 태스크는 삭제된 것이며, 붙어있지 않은 것은 롤링 업데이트로 새롭게 생성된 태스크이다.
   - \\_가 붙어있는 태스크는 어떠한 이유로든 동작을 멈춘 태스크로서, 서비스에서의 태스크 변경 기록을 나타낸다.
- 서비스를 생성할 때 롤링 업데이트의 주기, 업데이트응 동시에 진행할 컨테이너의 개수, 업데이트에 실패했을 때 어떻게 할 것인지를 설정할 수 있다.
  - 예) `docker service create --replicas 4 --name myweb3 --update-delay 10s --update-parallelism 2 nginx:1.10`
  - 각 태스크 레플리카를 10초 단위로 업데이트하며, 업데이트 작업을 한 번에 2개의 컨테이너에 수행한다는 것을 의미한다.
  - 이를 설정하지 않으면 주기 없이 차례대로 컨테이너를 한 개씩 업데이트한다.
- 서비스를 생성할 때 `--update-failure-action continue` 옵션을 넣어주면 업데이트 중 오류가 발생해도 계속 롤링 업데이트를 진행할 수 있게 한다.
  - 예) `docker service create --replicas 4 --name myweb4 --update-failure-action continue nginx:1.10`
- `docker service rollback [서비스]` 명령어로 서비스를 롤링 업데이트 이전으로 되돌릴 수 있다.
  - 예) `docker service rollback myweb3`

#### 3.3.5. 서비스 컨테이너에 설정 정보 전달하기 : config, secret
- 스웜 모드와 같은 서버 클러스터에서 파일 공유를 위해 설정 파일을 호스트마다 마련해두는 것은 비효율적이다.
  - 또한, 민감한 정보를 환경 변수로 설정하는 것은 보안상으로 위험하다.
- **secret**은 비밀번호나 SSH 키, 인증서 키와 같이 보안에 민감한 데이터를 전송하기 위해서 사용한다.
- **config**는 nginx나 레지스트리 설정 파일과 같이 암호화할 필요가 없는 설정 값들에 대해 사용한다.
- 위의 두 기능은 스웜 모드에서만 사용할 수 있다.

##### 3.3.5.1. secret 사용하기
    docker secret create [이름]
- secret 목록은 `docker secret ls` 명령어로 확인한다.
- secret 정보는 `docker secret inspect [이름]` 명령어로 확인한다.
  - 매니저 노드 간에 암호화된 상태로 저장되어 실제 값은 볼 수 없다.
- secret 파일은 배포한 뒤에도 파일 시스템이 아닌 메모리에 저장되기 때문에 서비스 컨테이너가 삭제될 경우 secret도 함께 삭제되는 휘발성을 띈다.
- 도커 서비스를 생성할 때 `--secret source source=[secret 이름],target=[컨테이너 내부에서 보여질 secret 이름]` 옵션을 넣으면, 특정 파일을 secret으로 만들 수 있다.
- 서비스에 접속하여 파일 내용을 확인하면 secret의 실제 값을 확인할 수 있다.
  - 이러한 방식의 값 전달은 컨테이너 내부의 애플리케이션이 특정 경로의 파일 값을 참조할 수 있도록 설계해야 한다.

##### 3.3.5.2. config 사용하기

#### 3.3.6. 도커 스웜 네트워크
- 스웜 모드는 여러 개의 도커 엔진에 같은 컨테이너를 분산해서 할당하기 때문에 각 도커 데몬의 네트워크가 하나로 묶인 네트워크 풀이 필요하다.
- 서비스를 외부로 노출했을 때 어느 노드로 접근하더라도  해당 서비스의 컨테이너에 접근할 수 있게 라우팅 기능이 필요하다.
- 매니저 노드에서 `docker network ls` 명령어로 네트워크의 목록을 학인해보면, **docker_gwbridge**와 **ingress** 네트워크가 있다.
  - **docker_gwbridge** 네트워크는 스웜에서 오버레이 네트워크를 사용할 때 사용된다.
  - **ingress** 네트워크는 로드 밸런싱과 라우팅 메시에 사용된다.

##### 3.3.6.1. ingress 네트워크
- ingress 네트워크는 스웜 클러스터를 생성하면 자동으로 등록되는 네트워크로서, 스웜 모드를 사용할 때만 유효하다.
- 매니저 노드뿐 아니라 스웜 클러스터에 등록된 모든 노드에 ingress 네트워크가 생성된다.
- 매니저 노드에 존재하는 컨테이너가 아니더라도 접근할 수 있다.
- 스웜 모드로 생성된 모든 태스크가 외부로 노출된기 위해 무조건 ingress 네트워크를 사용해야 하는 것은 아니다.
  - 호스트의 특정 포트를 사용하도록 설정할 수 있다.
    - 예) `docker service create --publish mode=host,target=80,published=8080,protocol=tcp --name web nginx`
  - ingress 네트워크를 사용하지 않고 서비스를 외부로 노출할 경우, 어느 호스트에서 컨테이너가 생성될지 알 수 없어 포트 및 서비스 관이가 어렵다.

##### 3.3.6.2. 오버레이 네트워크
- 스웜 클러스터 내의 태스크 내부에서 ifconfig로 IP 주소를 확인해보면, 컨테이너마다 eth0, eth1, lo가 할당되었고 eth0이 ingress 네트워크와 연결된 네트워크 카드다.
  - 매니저 노드와 워커 노드에서 생성된 태스크는 IP 주소가 차례로 할당된다.
- ingress 네트워크는 오버레이 네트워크 드라이버를 사용한다.
  - 오버레이 네트워크는 여러 개의 도커 데몬을 하나의 네트워크 풀로 만드는 네트워크 가상화 기술로서, 도커에 오버레이 네트워크를 적용하면 여러 도커 데몬에 존재하는 컨테이너가 서로 통신할 수 있다.
  - 즉, 여러 개의 스웜 노드에 할당된 태스크는 오버레이 네트워크 서브넷에 해당하는 IP 대역을 할당받고, 이 IP를 통해 서로 통신할 수 있다.

##### 3.3.6.3. docker_gwbridge 네트워크
- 오버레이 네트워크를 사용하지 않는 컨테이너는 기본적으로 존재하는 브리지 네트워크를 사용해 외부와 연결한다.
- 그러나, ingress를 포함한 모든 오버레이 네트워크는 이와 다른 브리지 네트워크인 docker_gwbridge 네트워크와 함께 사용된다.
  - docker_gwbridge 네트워크는 외부로 나가는 통신 및 오버레이 네트워크의 트래픽 종단점(VTEP) 역할을 담당한다.
- docker_gwbridge 네트워크는 컨테이너 내부의 네트워크 인터페이스 카드 중 eth1과 연결된다.

##### 사용자 정의 오버레이 네트워크
- 스웜 모드는 자체 키-값 저장소를 갖고 있으므로 별도의 구성 없이 사용자 정의 오버레이 네트워크를 생성하고 사용할 수 있다.
- `docker network create --subnet 10.0.9.0/24 -d overlay [생성될 네트워크의 이름]` 명령어로 생성할 수 있다.
  - 클러스터 내 한 노드에서만 실행해도 다른 노드에 자동으로 적용된다.
  - 각 노드에 해당 오버레이 네트워크를 사용하는 태스크가 할당될 때 적용된다.
- docker network ls 명령어로 생성한 오버레이 네트워크를 보면, 새롭게 생성된 오버레이 네트워크의 SCOPE가 swarm으로 설정되어 있다.
  - 즉, docker run 명령어로는 swarm의 SCOPE를 갖는 네트워크를 사용할 수 없다.
  - docker run --net 명령어로 스웜 모드의 오버레이 네트워크를 사용하려면 네트워크를 생성할 때 `--attachable` 옵션을 추가해야 한다.
  - 예)
    - `docker network create -d overlay --attachable myoverlay2`
    - `docker run -it --net myoverlay2 ubuntu:14.04`
- docker service create 명령어에 `--network` 옵션을 추가하면 오버레이 네트워크를 서비스에 적용해 태스크를 생성할 수 있다.
  - 예) `docker service create --name overlay_service --network myoverlay --replicas 2 alicek106/book:hostname`

#### 3.3.7. 서비스 디스커버리
- 같은 컨테이너를 여러 개 만들어 사용할 때 쟁점은 새로 생성된 컨테이너 생성의 발견(Service Discovery) 혹은 없어진 컨테이너의 감지이다.
- 일반적으로 이 동작은 주키퍼, etcd 등의 분산 분산 코디네이터를 외부에 두고 사용해서 해결하지만 스웜 모드는 서비스 발견 기능을 자체적으로 지원한다.
  - 예를 들어, docker service scale 명령어로 태스크를 늘려도 새로운 태스크에 모두 접근할 수 있다.

#### 3.3.8. 스웜 모드 볼륨
- 스웜 모드에서는 도커 볼륨을 사용할지, 호스트 외 디렉토리를 공유할지 좀 더 명확히 해 볼륨을 사용한다.
  - 즉, 서비스를 생성할 때 도커 볼륨을 사용할지 호스트와 디렉토리를 동유할지 명시해야 한다.

##### 3.3.8.1. volume 타입의 볼륨 생성
    docker service create --name [서비스 이름] --mount type=volune,source=[사용할 볼륨 이름],target=[경로] [이미지]
- 스웜 모드에서 도커 볼륨을 사용하는 서비스를 생성하려면 서비스를 생성할 때 **--mount** 옵션의 **type** 값에 **volume**을 지정한다.
  - source는 사용할 볼륨이고, target은 컨테이너 내부에 마운트될 디렉토리의 위치이다.
  - 도커 데몬에 이미 source에 해당하는 이름의 볼륨이 있으면 해덩 볼륨을 사용하지만, 없으면 새로 생성한다.
  - 예) `docker service create --name ubuntu --mount type=volume,source=myvol,target=/root ubuntu ping docker.com`
  - source 옵션을 명시하지 않으면,  임의의 16진수로 구성된 익명의 이름을 가진 볼륨을 생성한다.
- 태스크에서 볼륨에 공유할 태스크의 디렉토리에 파일이 이미 존재하면 이 파일들은 볼륨에 복사되고, 호스트에서 별도의 공간을 차지하게 된다.
  - 그러나, 서비스를 생성할 때 볼륨 옵션에 `volume-nocopy`를 추가하면 태스크의 파일들이 볼륨에 복사되지 않도록 설정할 수 있다.
  - 예) `docker service create --name ubuntu --mount type=volume,source=test,target=/etc/vim/,volume-nocopy ubuntu:14.04 ping docker.co`m`

##### 3.3.8.2. bind 타입의 볼륨 생성
- 바인드 타입은 호스트와 디렉토리를 공유할 때 사용된다.
- 볼륨 타입과는 달리 공유될 호스트의 디렉토리를 설정해야 하므로 source 옵션을 반드시 명시해야 한다.
- 바인드 타입은 type 옵션의 값을 `bind`로 설정해서 사용할 수 있다.
  - 예) `docker service create --name ubuntu --mount type=bind,source=/root/hpst,target/root/container ubuntu:14.04 ping docker.com`
  - 호스트의 /root/host 디렉토리를 태스크의 /root/container 디렉토리에 마운트한다는 의미이다.

##### 3.3.8.3. 스웜 모드에서 볼륨의 한계점
- 서비스를 할당받을 수 있는 모든 노드가 볼륨 데이터를 가지고 있어야 하기 때문에, 스웜 클러스터에서 볼륨을 사용하기가 까다롭다.
- 스웜 매니저에 내장된 스케줄러가 컨테이너를 할당할 때 어느 노드에 할당해도 서비스에 정의된 볼륨을 사용할 수 있어야 한다.
  - 따라서, 여러 개의 도커 데몬을 관리해야 하는 스웜 모드에서는 도커 볼륨 또는 호스트와의 볼륨 사용이 적합하지 않을 수 있다.

### 3.4. 도커 스웜 모드 노드 다루기
- 스웜 모드가 제공하는 기본 기능만으로도 목적에 부합하는 스케줄링 전략을 새울 수 있다.

#### 3.4.1. 노드 AVAILAVILITY 변경하기
- 일반적으로, 매니저와 같은 마스터 노드는 최대한 부하를 받지 않도록 서비스를 할당받지 않게 하는 것이 좋다.
- 또는 특정 노드에 문제가 발생하여 유지보수 작업을 수행할 때 해당 노드에 태스크를 할당하지 않게 하고 싶을 수도 있다.
- 이를 위해 특정 노드의 AVAILABILITY를 설정함으로써 태스크의 할당 가능 여부를 변경할 수 있다.

##### 3.4.1.1. Active
    docker node update --availability active [노드 이름]
- Active 상태는 새로운 노드가 스웜 클러스터에 추가되면 기본적으로 설정되는 상태로서, 노드가 태스크를 할당받을 수 있음을 의미한다.

##### 3.4.1.2. Drain
    docker node update --availability drain [노드 이름]
- 노드를 Drain 상태로 설정하면 스뭠 매니저의 스케줄러는 태스크를 해당 노드에 할당하지 않는다.
- Drain 상태는 일반적으로 매니저 노드애 설정하는 상태지만, 노드에 문제가 생겨 일시적으로 사용하지 않는 상태로 설정해야 할 때도 자주 사용된다.
- 노드를 Drain 상태로 변경하면 해당 노드에서 실행 중이던 태스크는 전부 중지되고 Active 상태의 노드로 다시 할당된다.

##### 3.4.1.3. Pause
    docker node update --availability pause [노드 이름]
  - Pause 상태는 태스크를 더는 할당박지 않는다는 점에서는 Drain과 같지만, 실행중인 태스크가 중지되지 않는다는 점에서 다르다.

#### 3.4.2. 노드 라벨 추가
- 라벨은 키-값 형태를 가지고 있으며 키 값으로 노드를 구별할 수 있기 때문에, 노드에 라벨을 추가하는 것은 노드를 분류하는 것과 비슷하다.
- 특정 노드에 라벨을 추가하면 서비스에 할당할 때 태스크를 생성할 노드의 그룹을 선택하는 것이 가능하다.
  - 만약 어떤 한 노드가 SSD 스토리지를 사용하고 있어 strage=ssd라는 라벨을 설정했다고 가정했을 때, 서비스가 하드웨어에 종속적이기 때문에 SSD를 사용하는 노드에서 수행해야 한다면, starage=ssd 라벨을 가진 노드에만 태스크를 할당할 수 있다.

##### 3.4.2.1. 노드 라벨 추가하기
    docker node update --label-add [키]=[값] [노드 이름]
- 설정된 라벨은 `docker node inspect [노드 이름]` 명령어로 확인활 수 있다.

##### 3.4.2.2. 서비스 제약 설정
- docker service create 명령어애 `--constraint` 옵션을 추가하여 태스크가 할당될 노드의 종류를 선택할 수 있다.
- 노드에 라벨을 추가함으로써 제약조건을 설정할 수도 있지만 노드의 ID나 호스트의 이름, 도커 데몬 라벵 등으로도 제약조건을 설정할 수 있다.
- --constraint에서는 특정 조건을 찾기 위해 ==를, 특정 조건을 선택하지 않도록 !=를 사용할 수 있다.
1. node.labels 제약조건
   - 다음 명령는 storage 키의 값이 ssd로 설정된 노드에 태스크를 할당한다.
   - 예) `docker service create --name label_test --constraint 'node.labels.storage == ssd' --replicas=5 ubuntu:14.04 ping docker.com`
2. node.id 제약조건
   - 다음 명령은 node.id 조건에 노드의 ID를 명시하여 태스크를 할당할 노드를 선택한다.
   - 단, 다른 도커 명령어와 달리 ID의 앞의 일부분만 입력하면 도커가 인식하지 못하므로, docker node ls 명령어에 출력된 ID를 전부 입력해야 한다.
   - 예) `docker service create --name label_test2 --constraint 'node.id == xjwmyc3c22o1elpcuwr5b1cu5' --replicas=5 ubuntu:14.04 ping docker.com`
3. node.hostname과 node.role 제약조건
   - 스웜 클러스터에 등록된 호스트 이름 및 역할로 제한조건을 설정할 수도 있다.
   - 예) `docker service create --name label_test3 --constraint 'node.hostname == swarm-worker1' ubuntu:14.04 ping docker.com`
   - 예) d`ocker service create --name label_test4 --constraint 'node.role != manager' ubuntu:14.04 ping docker.com`
4. engine.labels 제약조건
- 도커 엔진, 즉 도커 데몬 자체에 라벨을 설정하려 제한조건을 설정할 수 있지만 이를 사용하려면 도커 데몬의 실행 옵션을 변경해야 한다.
- 서비스를 생성할 때 engine.labels를 접두어로 제한조건을 설정하면, 도커 데몬의 라벨을 사용할 수 있다.
  - 예) `docker service create --name engine_label --constraint 'engine.labels.mylabel == worker2' --replicas=3 ubuntu:14.04 ping docker.com`
- 제한조건은 동시에 여러개를 사용할 수도 있다.
